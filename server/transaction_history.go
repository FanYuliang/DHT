// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package server

import (
	"golang.org/x/tools/go/ssa/interp/testdata/src/fmt"
	"sync"
)

//cat generic_ccmap.go | genny gen "Key=string TransactionEntry=*blockchain.Transaction" > [targetName].go

// TransactionHistory the set of Items
type TransactionHistory struct {
	items []TransactionEntry
	lock  sync.RWMutex
}

// Set adds a new item to the tail of the list
func (d *TransactionHistory) Append(v TransactionEntry) {
	d.lock.Lock()
	defer d.lock.Unlock()
	fmt.Println("Append new transaction entry: ", v)
	if d.items == nil {
		d.items = make([]TransactionEntry, 0)
	}
	d.items = append(d.items, v)
}

// GetTransactionToCommit front
func (d *TransactionHistory) Pop(n int) []TransactionEntry {
	d.lock.Lock()
	defer d.lock.Unlock()
	var res []TransactionEntry
	if n < len(d.items) {
		res = d.items[:n]
		d.items = d.items[n:]
	} else {
		res = d.items
		d.items = make([]TransactionEntry, 0)
	}
	return res
}

func (d *TransactionHistory) Size() int {
	d.lock.RLock()
	defer d.lock.RUnlock()
	return len(d.items)
}

func (d *TransactionHistory) Get(idx int) *TransactionEntry {
	d.lock.RLock()
	defer d.lock.RUnlock()
	if idx > len(d.items){
		return nil
	}
	return &d.items[idx]
}

func (d *TransactionHistory) Delete(idx int) *TransactionEntry {
	d.lock.Lock()
	defer d.lock.Unlock()
	if idx > len(d.items) {
		return nil
	}
	temp := d.items[idx]
	d.items = append(d.items[:idx], d.items[idx+1:]...)
	return &temp
}

func (d *TransactionHistory) DeleteTransaction(id string) [] TransactionEntry{
	d.lock.Lock()
	defer d.lock.Unlock()
	res := make([]TransactionEntry, 0)
	for i := len(d.items) - 1; i >= 0; i-- {
		if d.items[i].transactionID == id {
			currEntry := d.items[i]
			res = append(res, currEntry)
			d.items = append(d.items[:i], d.items[i+1:]...)
		}
	}
	return res
}